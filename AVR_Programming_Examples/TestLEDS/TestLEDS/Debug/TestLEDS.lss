
TestLEDS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000268  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000001f4  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000001  00800100  00800100  00000268  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000268  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000298  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000050  00000000  00000000  000002d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000988  00000000  00000000  00000324  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000738  00000000  00000000  00000cac  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000329  00000000  00000000  000013e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000d0  00000000  00000000  00001710  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000003d2  00000000  00000000  000017e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000021d  00000000  00000000  00001bb2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000040  00000000  00000000  00001dcf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	19 c0       	rjmp	.+50     	; 0x34 <__ctors_end>
   2:	28 c0       	rjmp	.+80     	; 0x54 <__bad_interrupt>
   4:	27 c0       	rjmp	.+78     	; 0x54 <__bad_interrupt>
   6:	26 c0       	rjmp	.+76     	; 0x54 <__bad_interrupt>
   8:	25 c0       	rjmp	.+74     	; 0x54 <__bad_interrupt>
   a:	38 c0       	rjmp	.+112    	; 0x7c <__vector_5>
   c:	23 c0       	rjmp	.+70     	; 0x54 <__bad_interrupt>
   e:	22 c0       	rjmp	.+68     	; 0x54 <__bad_interrupt>
  10:	21 c0       	rjmp	.+66     	; 0x54 <__bad_interrupt>
  12:	20 c0       	rjmp	.+64     	; 0x54 <__bad_interrupt>
  14:	1f c0       	rjmp	.+62     	; 0x54 <__bad_interrupt>
  16:	1e c0       	rjmp	.+60     	; 0x54 <__bad_interrupt>
  18:	1d c0       	rjmp	.+58     	; 0x54 <__bad_interrupt>
  1a:	1c c0       	rjmp	.+56     	; 0x54 <__bad_interrupt>
  1c:	1b c0       	rjmp	.+54     	; 0x54 <__bad_interrupt>
  1e:	1a c0       	rjmp	.+52     	; 0x54 <__bad_interrupt>
  20:	19 c0       	rjmp	.+50     	; 0x54 <__bad_interrupt>
  22:	18 c0       	rjmp	.+48     	; 0x54 <__bad_interrupt>
  24:	17 c0       	rjmp	.+46     	; 0x54 <__bad_interrupt>
  26:	16 c0       	rjmp	.+44     	; 0x54 <__bad_interrupt>
  28:	15 c0       	rjmp	.+42     	; 0x54 <__bad_interrupt>
  2a:	14 c0       	rjmp	.+40     	; 0x54 <__bad_interrupt>
  2c:	13 c0       	rjmp	.+38     	; 0x54 <__bad_interrupt>
  2e:	12 c0       	rjmp	.+36     	; 0x54 <__bad_interrupt>
  30:	11 c0       	rjmp	.+34     	; 0x54 <__bad_interrupt>
  32:	10 c0       	rjmp	.+32     	; 0x54 <__bad_interrupt>

00000034 <__ctors_end>:
  34:	11 24       	eor	r1, r1
  36:	1f be       	out	0x3f, r1	; 63
  38:	cf ef       	ldi	r28, 0xFF	; 255
  3a:	d4 e0       	ldi	r29, 0x04	; 4
  3c:	de bf       	out	0x3e, r29	; 62
  3e:	cd bf       	out	0x3d, r28	; 61

00000040 <__do_clear_bss>:
  40:	21 e0       	ldi	r18, 0x01	; 1
  42:	a0 e0       	ldi	r26, 0x00	; 0
  44:	b1 e0       	ldi	r27, 0x01	; 1
  46:	01 c0       	rjmp	.+2      	; 0x4a <.do_clear_bss_start>

00000048 <.do_clear_bss_loop>:
  48:	1d 92       	st	X+, r1

0000004a <.do_clear_bss_start>:
  4a:	a1 30       	cpi	r26, 0x01	; 1
  4c:	b2 07       	cpc	r27, r18
  4e:	e1 f7       	brne	.-8      	; 0x48 <.do_clear_bss_loop>
  50:	c9 d0       	rcall	.+402    	; 0x1e4 <main>
  52:	ce c0       	rjmp	.+412    	; 0x1f0 <_exit>

00000054 <__bad_interrupt>:
  54:	d5 cf       	rjmp	.-86     	; 0x0 <__vectors>

00000056 <set_PWM>:
  } else {
    set_LED(3, 0);
  }
}
void set_PWM(int direction) {
  if (direction == 1) {
  56:	81 30       	cpi	r24, 0x01	; 1
  58:	91 05       	cpc	r25, r1
  5a:	39 f4       	brne	.+14     	; 0x6a <set_PWM+0x14>
    if (OCR0A <= 255 - 5) { // avoid overflow
  5c:	87 b5       	in	r24, 0x27	; 39
  5e:	8b 3f       	cpi	r24, 0xFB	; 251
  60:	60 f4       	brcc	.+24     	; 0x7a <set_PWM+0x24>
      OCR0A += 5;
  62:	87 b5       	in	r24, 0x27	; 39
  64:	8b 5f       	subi	r24, 0xFB	; 251
  66:	87 bd       	out	0x27, r24	; 39
  68:	08 95       	ret
    }
  } else if (direction == -1) {
  6a:	01 96       	adiw	r24, 0x01	; 1
  6c:	31 f4       	brne	.+12     	; 0x7a <set_PWM+0x24>
    if (OCR0A >= 5) { // avoid underflow
  6e:	87 b5       	in	r24, 0x27	; 39
  70:	85 30       	cpi	r24, 0x05	; 5
  72:	18 f0       	brcs	.+6      	; 0x7a <set_PWM+0x24>
      OCR0A -= 5;
  74:	87 b5       	in	r24, 0x27	; 39
  76:	85 50       	subi	r24, 0x05	; 5
  78:	87 bd       	out	0x27, r24	; 39
  7a:	08 95       	ret

0000007c <__vector_5>:
    set_LED(1, 1);
    //_delay_ms(1000);
  }
}

ISR(PCINT2_vect) {
  7c:	1f 92       	push	r1
  7e:	0f 92       	push	r0
  80:	0f b6       	in	r0, 0x3f	; 63
  82:	0f 92       	push	r0
  84:	11 24       	eor	r1, r1
  86:	2f 93       	push	r18
  88:	3f 93       	push	r19
  8a:	4f 93       	push	r20
  8c:	5f 93       	push	r21
  8e:	6f 93       	push	r22
  90:	7f 93       	push	r23
  92:	8f 93       	push	r24
  94:	9f 93       	push	r25
  96:	af 93       	push	r26
  98:	bf 93       	push	r27
  9a:	cf 93       	push	r28
  9c:	ef 93       	push	r30
  9e:	ff 93       	push	r31
  uint8_t this_state = (PIND & 0x0C); // mask for PD2 + PD3
  a0:	c9 b1       	in	r28, 0x09	; 9
  a2:	cc 70       	andi	r28, 0x0C	; 12

  // Ignore if no change (bouncing or multiple interrupts)
  if (this_state == prev_state) {
  a4:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
  a8:	c8 17       	cp	r28, r24
  aa:	09 f4       	brne	.+2      	; 0xae <__vector_5+0x32>
  ac:	5c c0       	rjmp	.+184    	; 0x166 <__vector_5+0xea>
    return;
  }

  // Forward sequence: 0 -> 8 -> 12 -> 4 -> 0
  if (prev_state == 0 && this_state == 8) {
  ae:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
  b2:	81 11       	cpse	r24, r1
  b4:	06 c0       	rjmp	.+12     	; 0xc2 <__vector_5+0x46>
  b6:	c8 30       	cpi	r28, 0x08	; 8
  b8:	21 f4       	brne	.+8      	; 0xc2 <__vector_5+0x46>
    set_PWM(1);
  ba:	81 e0       	ldi	r24, 0x01	; 1
  bc:	90 e0       	ldi	r25, 0x00	; 0
  be:	cb df       	rcall	.-106    	; 0x56 <set_PWM>
  c0:	45 c0       	rjmp	.+138    	; 0x14c <__vector_5+0xd0>
  } else if (prev_state == 8 && this_state == 12) {
  c2:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
  c6:	88 30       	cpi	r24, 0x08	; 8
  c8:	31 f4       	brne	.+12     	; 0xd6 <__vector_5+0x5a>
  ca:	cc 30       	cpi	r28, 0x0C	; 12
  cc:	21 f4       	brne	.+8      	; 0xd6 <__vector_5+0x5a>
    set_PWM(1);
  ce:	81 e0       	ldi	r24, 0x01	; 1
  d0:	90 e0       	ldi	r25, 0x00	; 0
  d2:	c1 df       	rcall	.-126    	; 0x56 <set_PWM>
  d4:	3b c0       	rjmp	.+118    	; 0x14c <__vector_5+0xd0>
  } else if (prev_state == 12 && this_state == 4) {
  d6:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
  da:	8c 30       	cpi	r24, 0x0C	; 12
  dc:	31 f4       	brne	.+12     	; 0xea <__vector_5+0x6e>
  de:	c4 30       	cpi	r28, 0x04	; 4
  e0:	21 f4       	brne	.+8      	; 0xea <__vector_5+0x6e>
    set_PWM(1);
  e2:	81 e0       	ldi	r24, 0x01	; 1
  e4:	90 e0       	ldi	r25, 0x00	; 0
  e6:	b7 df       	rcall	.-146    	; 0x56 <set_PWM>
  e8:	31 c0       	rjmp	.+98     	; 0x14c <__vector_5+0xd0>
  } else if (prev_state == 4 && this_state == 0) {
  ea:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
  ee:	84 30       	cpi	r24, 0x04	; 4
  f0:	31 f4       	brne	.+12     	; 0xfe <__vector_5+0x82>
  f2:	c1 11       	cpse	r28, r1
  f4:	04 c0       	rjmp	.+8      	; 0xfe <__vector_5+0x82>
    set_PWM(1);
  f6:	81 e0       	ldi	r24, 0x01	; 1
  f8:	90 e0       	ldi	r25, 0x00	; 0
  fa:	ad df       	rcall	.-166    	; 0x56 <set_PWM>
  fc:	27 c0       	rjmp	.+78     	; 0x14c <__vector_5+0xd0>
  }
  // Backward sequence: 0 -> 4 -> 12 -> 8 -> 0
  else if (prev_state == 0 && this_state == 4) {
  fe:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 102:	81 11       	cpse	r24, r1
 104:	06 c0       	rjmp	.+12     	; 0x112 <__vector_5+0x96>
 106:	c4 30       	cpi	r28, 0x04	; 4
 108:	21 f4       	brne	.+8      	; 0x112 <__vector_5+0x96>
    set_PWM(-1);
 10a:	8f ef       	ldi	r24, 0xFF	; 255
 10c:	9f ef       	ldi	r25, 0xFF	; 255
 10e:	a3 df       	rcall	.-186    	; 0x56 <set_PWM>
 110:	1d c0       	rjmp	.+58     	; 0x14c <__vector_5+0xd0>
  } else if (prev_state == 4 && this_state == 12) {
 112:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 116:	84 30       	cpi	r24, 0x04	; 4
 118:	31 f4       	brne	.+12     	; 0x126 <__vector_5+0xaa>
 11a:	cc 30       	cpi	r28, 0x0C	; 12
 11c:	21 f4       	brne	.+8      	; 0x126 <__vector_5+0xaa>
    set_PWM(-1);
 11e:	8f ef       	ldi	r24, 0xFF	; 255
 120:	9f ef       	ldi	r25, 0xFF	; 255
 122:	99 df       	rcall	.-206    	; 0x56 <set_PWM>
 124:	13 c0       	rjmp	.+38     	; 0x14c <__vector_5+0xd0>
  } else if (prev_state == 12 && this_state == 8) {
 126:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 12a:	8c 30       	cpi	r24, 0x0C	; 12
 12c:	31 f4       	brne	.+12     	; 0x13a <__vector_5+0xbe>
 12e:	c8 30       	cpi	r28, 0x08	; 8
 130:	21 f4       	brne	.+8      	; 0x13a <__vector_5+0xbe>
    set_PWM(-1);
 132:	8f ef       	ldi	r24, 0xFF	; 255
 134:	9f ef       	ldi	r25, 0xFF	; 255
 136:	8f df       	rcall	.-226    	; 0x56 <set_PWM>
 138:	09 c0       	rjmp	.+18     	; 0x14c <__vector_5+0xd0>
  } else if (prev_state == 8 && this_state == 0) {
 13a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 13e:	88 30       	cpi	r24, 0x08	; 8
 140:	29 f4       	brne	.+10     	; 0x14c <__vector_5+0xd0>
 142:	c1 11       	cpse	r28, r1
 144:	03 c0       	rjmp	.+6      	; 0x14c <__vector_5+0xd0>
    set_PWM(-1);
 146:	8f ef       	ldi	r24, 0xFF	; 255
 148:	9f ef       	ldi	r25, 0xFF	; 255
 14a:	85 df       	rcall	.-246    	; 0x56 <set_PWM>
  }
  // Any other weird jump: ignore
  else {
    // do nothing
  }
  prev_state = this_state;
 14c:	c0 93 00 01 	sts	0x0100, r28	; 0x800100 <__DATA_REGION_ORIGIN__>
  switch (position) {
  case 1:
    if (value) {
      PORTB &= ~(1 << PB7);
    } else {
      PORTB |= (1 << PB7);
 150:	2f 9a       	sbi	0x05, 7	; 5
  prev_state = this_state;

  // This is the exact same code as used when polling!
  set_LED(1, 0);

  if ((PIND & (1 << PIND2))) {
 152:	4a 9b       	sbis	0x09, 2	; 9
 154:	02 c0       	rjmp	.+4      	; 0x15a <__vector_5+0xde>
      PORTB |= (1 << PB7);
    }
    break;
  case 2:
    if (value) {
      PORTC &= ~(1 << PC4);
 156:	44 98       	cbi	0x08, 4	; 8
 158:	01 c0       	rjmp	.+2      	; 0x15c <__vector_5+0xe0>
    } else {
      PORTC |= (1 << PC4);
 15a:	44 9a       	sbi	0x08, 4	; 8
  if ((PIND & (1 << PIND2))) {
    set_LED(2, 1);
  } else {
    set_LED(2, 0);
  }
  if ((PIND & (1 << PIND3))) {
 15c:	4b 9b       	sbis	0x09, 3	; 9
 15e:	02 c0       	rjmp	.+4      	; 0x164 <__vector_5+0xe8>
      PORTC |= (1 << PC4);
    }
    break;
  case 3:
    if (value) {
      PORTD &= ~(1 << PD7);
 160:	5f 98       	cbi	0x0b, 7	; 11
 162:	01 c0       	rjmp	.+2      	; 0x166 <__vector_5+0xea>
    } else {
      PORTD |= (1 << PD7);
 164:	5f 9a       	sbi	0x0b, 7	; 11
  if ((PIND & (1 << PIND3))) {
    set_LED(3, 1);
  } else {
    set_LED(3, 0);
  }
}
 166:	ff 91       	pop	r31
 168:	ef 91       	pop	r30
 16a:	cf 91       	pop	r28
 16c:	bf 91       	pop	r27
 16e:	af 91       	pop	r26
 170:	9f 91       	pop	r25
 172:	8f 91       	pop	r24
 174:	7f 91       	pop	r23
 176:	6f 91       	pop	r22
 178:	5f 91       	pop	r21
 17a:	4f 91       	pop	r20
 17c:	3f 91       	pop	r19
 17e:	2f 91       	pop	r18
 180:	0f 90       	pop	r0
 182:	0f be       	out	0x3f, r0	; 63
 184:	0f 90       	pop	r0
 186:	1f 90       	pop	r1
 188:	18 95       	reti

0000018a <init_LEDs>:
    }
  }
}

int init_LEDs(void) {
  DDRB |= (1 << PB7);
 18a:	27 9a       	sbi	0x04, 7	; 4
  DDRC |= (1 << PC4); // Corresponding pins set as outputs 0b 0000 1111
 18c:	3c 9a       	sbi	0x07, 4	; 7
  DDRD |= (1 << PD7);
 18e:	57 9a       	sbi	0x0a, 7	; 10
  PORTB &= ~(1 << PB7);
 190:	2f 98       	cbi	0x05, 7	; 5
  PORTC &= ~(1 << PC4); // Initially all LED pins set to 0
 192:	44 98       	cbi	0x08, 4	; 8
  PORTD &= ~(1 << PD7);
 194:	5f 98       	cbi	0x0b, 7	; 11

  return 1;
}
 196:	81 e0       	ldi	r24, 0x01	; 1
 198:	90 e0       	ldi	r25, 0x00	; 0
 19a:	08 95       	ret

0000019c <init_INTs>:

int init_INTs(void) {
  // PD2 and PD3 as inputs
  DDRD &= ~((1 << DDD2) | (1 << DDD3));
 19c:	8a b1       	in	r24, 0x0a	; 10
 19e:	83 7f       	andi	r24, 0xF3	; 243
 1a0:	8a b9       	out	0x0a, r24	; 10

  // Optional: internal pull-ups if the encoder has open switches
  PORTD |= (1 << PD2) | (1 << PD3);
 1a2:	8b b1       	in	r24, 0x0b	; 11
 1a4:	8c 60       	ori	r24, 0x0C	; 12
 1a6:	8b b9       	out	0x0b, r24	; 11

  // Enable pin change interrupts on PD2 (PCINT18) and PD3 (PCINT19)
  PCMSK2 |= (1 << PCINT18) | (1 << PCINT19);
 1a8:	ed e6       	ldi	r30, 0x6D	; 109
 1aa:	f0 e0       	ldi	r31, 0x00	; 0
 1ac:	80 81       	ld	r24, Z
 1ae:	8c 60       	ori	r24, 0x0C	; 12
 1b0:	80 83       	st	Z, r24

  // Enable pin change interrupt group 2 (PCINT[23:16] = Port D)
  PCICR |= (1 << PCIE2);
 1b2:	e8 e6       	ldi	r30, 0x68	; 104
 1b4:	f0 e0       	ldi	r31, 0x00	; 0
 1b6:	80 81       	ld	r24, Z
 1b8:	84 60       	ori	r24, 0x04	; 4
 1ba:	80 83       	st	Z, r24

  return 1;
}
 1bc:	81 e0       	ldi	r24, 0x01	; 1
 1be:	90 e0       	ldi	r25, 0x00	; 0
 1c0:	08 95       	ret

000001c2 <init_PWM>:

int init_PWM(void) {
  // PD6 (OC0A) as output
  DDRD |= (1 << DDD6);
 1c2:	56 9a       	sbi	0x0a, 6	; 10

  TCCR0A = 0;
 1c4:	14 bc       	out	0x24, r1	; 36
  TCCR0B = 0;
 1c6:	15 bc       	out	0x25, r1	; 37

  TCCR0A |= (1 << WGM00);
 1c8:	84 b5       	in	r24, 0x24	; 36
 1ca:	81 60       	ori	r24, 0x01	; 1
 1cc:	84 bd       	out	0x24, r24	; 36

  // Non-inverting PWM on OC0A: COM0A1:0 = 0b10
  TCCR0A |= (1 << COM0A1);
 1ce:	84 b5       	in	r24, 0x24	; 36
 1d0:	80 68       	ori	r24, 0x80	; 128
 1d2:	84 bd       	out	0x24, r24	; 36
  TCCR0A &= ~(1 << COM0A0);
 1d4:	84 b5       	in	r24, 0x24	; 36
 1d6:	8f 7b       	andi	r24, 0xBF	; 191
 1d8:	84 bd       	out	0x24, r24	; 36

  // Prescaler: clk/8  (CS01 = 1)
  // F_PWM = F_CPU / (2 * N * 256) = 1MHz / (2*8*256) ? 244 Hz
  TCCR0B |= (1 << CS01);
 1da:	85 b5       	in	r24, 0x25	; 37
 1dc:	82 60       	ori	r24, 0x02	; 2
 1de:	85 bd       	out	0x25, r24	; 37

  // Start with 0% duty
  OCR0A = 0;
 1e0:	17 bc       	out	0x27, r1	; 39
}
 1e2:	08 95       	ret

000001e4 <main>:
  // Local variables declaration
  char ChannelA, ChannelB;
  int8_t TOP = 255;
  int8_t BOTTOM = 0;

  init_LEDs();
 1e4:	d2 df       	rcall	.-92     	; 0x18a <init_LEDs>

  // Keep interrupts disabled for now (pure polling test)
  init_INTs();
 1e6:	da df       	rcall	.-76     	; 0x19c <init_INTs>
  init_PWM();
 1e8:	ec df       	rcall	.-40     	; 0x1c2 <init_PWM>
  sei();
 1ea:	78 94       	sei

int set_LED(int position, int value) {
  switch (position) {
  case 1:
    if (value) {
      PORTB &= ~(1 << PB7);
 1ec:	2f 98       	cbi	0x05, 7	; 5
 1ee:	fe cf       	rjmp	.-4      	; 0x1ec <main+0x8>

000001f0 <_exit>:
 1f0:	f8 94       	cli

000001f2 <__stop_program>:
 1f2:	ff cf       	rjmp	.-2      	; 0x1f2 <__stop_program>
